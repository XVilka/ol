---
layout: page
title:  Организация памяти виртуальной машины Ol
date: 2016-11-10 17:21:24 UTC
categories: en
---


   Виртуальная машина Otus Lisp (olvm) является регистровой (R) виртуальной машиной, использующей для долговременного хранения данных динамическую кучу (Heap) под управлением сборщика мусора (Garbage collector, GC).

   Все данные, которыми оперирует olvm, как и в большинстве других языков программирования с динамической типизацией, делятся на две большие горуппы - значения value типа и значения reference типа.

   Значения value типа представляют собой непосредственные значения,  такие как константы (#true, #false) и небольшие числа (0, 1, 101); reference типа - указатели на объекты, размещаемые в памяти (списки, строки, кортежи). Объекты никогда не передаются по значению, только по ссылке. Value значения никогда не передаются по ссылке, только по значению. Чтобы сохранить value зеачние в памяти, его надо разместить в каком-либо reference объекте, например точечной паре.

### Регистры

   Регистров у olvm в насчитывается 128. Это число зависит от реализации и может быть задано в lang/register.scm как (define n-registers 128) и src/olvm.c как #define NR 128. Значения регистров программисту непосредственно недоступны.

   В регистрах хранятся либо ссылки на размещенные в куче объекты (references), либо непосредственные значения value типа.

   В процессе сборки мусора (gc, о ней чуть позже) именно значения регистров являются тем корнем, от которого начинает работать сборщик мусора. Все объекты, не доступные ни из одного регистра и из текущего контекста считаются мусором и отбрасываются в процессе сборки. Такой подход позволяет эффективно справляться с циклическимиз зависимостями уже ненужных объектов.
   
   Еще более детально - значения регистров складываются в куче в новый кортеж, который назначается корнем сборки. После сборки регистры восстанавливаются из кортежа, а кортеж уничтожается.
Вот пример кода, который это делает:
<pre><code>
   int p = 0, N = NR;
   word *regs = (word*) new_tuple (N + 1);
   while (++p <= N) regs[p] = R[p-1];
   regs[p] = (word) this; // текущий контекст

   heap.fp = fp;
   regs = (word*) gc(&heap, size, (word)regs);
   fp = heap.fp;

   this = (word *) regs[p];
   while (--p >= 1) R[p-1] = regs[p];
   fp = regs; // удалим созданный выше tuple
</code></pre>

### Куча

   Используемая olvm память, или "куча" (Heap), представляет собой динамически изменяемый линейный массив объектов, управляемый сборщиком мусора (Garbage Collector, GC). Ничего кроме объектов в куче разместить нельзя. Необходимо помнить, что в куче всегда резервируется место для внутреннего использования виртуальной машиной размером в количество регистров плюс два слов плюс один килобайт. 
   
   Размер кучи меняется только в процессе полной сборки мусора (о сборке будет дальше). Стратегия изменения размера кучи довольно проста: если свободное место в куче закончилось (меньше запрошенного у GC места, то куча увеличивается на 1/10 использованного размера плюс 4 килобайта; если же свободного места больше чем 20%, то куча уменьшается до 10% свободного места.

   Объект состоит из двух частей, заголовка (header) и наполнения (payload). Вот формат заголовка:
<pre><code>
   [... ssssssss ????rppp tttttt10]  ; два младших бита заголовока всегда(!) равны 10
    '----------| '--||'-| '----|
               |    ||  |      '-----> тип объекта, 6 бит
               |    ||  '------------> количество байт заполнения (padding), после конца raw-объектов, 3 бита
               |    |'---------------> бит "сырости" объекта (rawness), такие объекты содержат только линейный массив байт
               |    '----------------> зарезервированные биты, 4 бита
               '---------------------> размер объекта в машинных словах (размер слова минус 8 бит)
</code></pre>

   Наполнение объекта зависит от бита rawness. Если этот бит установлен, то объект содержит линейный массив битовых данных. Размер такого массива равен размеру объекта умноженному на количество байт в слове минус количество байт заполнения.
   
   Если же этот бит сброшен, то объект содержит линейный массив состоящий из либо value значений, либо обычных ссылок на память (на заголовки других объектов), либо и тех и тех вперемешку.
   
### Сборка мусора

   Исходные коды виртуальной машины содержват несколько функций (макросов) для выделения блоков памяти в куче под объекты (прошу еще заметить, что память выделяется только для объектов, непосредственные значения (value) в памяти не выделяются и полностью содержватся в регистрах, в то время как на объекты в регистрах содержватся ссылки).
   
   Вот список аллокаторов с указанием выделяемого в куче общего размера:
   * new(size) - *size* - выделение блока памяти без указания типа, самое "опасное" выделение, так как в заголовок блока не вносится совершенно никаких данных; является базовым аллокатором для всех последующих
   * new(type, size) - *size* - выделение блока памяти с одновременным заполнением заголовка типом и размером
   * new(type, size, pads) - *size* - выделение "сырого" блока памяти с одновременным заполнением заголовка типом и размером, "сырые" блоки, это блоки содержащие битовые последовательности, так как строки или байткод
   
   * new_pair(a1, a2) - *3 x W* - аналог (cons a1 a2), выделает объект типа TPAIR и заполняет его первый и второй элементы
   * new_pair(type, a1, a2) - *3 x W* - делает то же самое, что и предыдущий аллокатор, но с указанием требуемого типа
   
   * new_list(type, a1) .. new_list(type, a1, a2, a3, a4, a5) - *TBD* - создает цепочку объектов, list, с корректным заполнением
   
   * new_tuple(a1) .. new_tuple(a1,a2,..,a13) - *TBD* - создает кортеж объектов, tuple, с корректным заполнением; прошу заметить, что кортеж не является raw объектом и содержит либо value, либо reference данные, не битовые последовательности.
   
   * new_bytevector(type, length) - *TBD* - создает "сырой" объект, битовую последовательность указанного типа
   
   * new_string(string) - *TBD* - создает строку длины идентичной аргументу и копирует в нее значение аргумента; концом строки считается завершающий \0
   * new_string(string, length) - *TBD* - создает строку заданной длины и копирует в нее length элементов аргумента

   * new_vptr(a) - *2 x W* - создает новый небезопасный (unsafe) указатель, используется в pinvoke механизме связывания с внешними библиотеками, является сырым объектом
   * new_userdata(a) - *2 x W* - создает новый "бестиповый" элемент, интерпретация которого ложится на плечи программиста, так же является сырым объектом
   
   Вот и все 7 разных аллокаторов, используемых в ol.
   
   С точки зрения ...
   TBD.
---
layout: page
title:  Виртуальная машина Otus Lisp
date: 2016-11-28 15:51:55 UTC
categories: ru, olvm
---

   Виртуальная машина ol (Otus Lisp Virtual Machine - olvm) является регистровой (R) виртуальной машиной, использующей для долговременного хранения данных динамическую кучу (Heap) под управлением сборщика мусора (Garbage Collector, GC).

   Все данные, которыми оперирует olvm, как и в большинстве других языков программирования с динамической типизацией, делятся на два типа - непосредственный (value) тип и ссылочный (reference) тип.

   Значения value типа представляют собой непосредственные значения, такие как небольшие числа, константы #true и #false; reference типа - указатели на объекты, размещаемые в памяти. Объекты никогда и никуда не передаются по значению, только по ссылке. Value значения никогда не передаются по ссылке, только по значению.

   Если надо сохранить в памяти значение value типа, например для ссылки на него из другого места, то его надо упаковать в, например, пару (cons) и только тогда сохранить. Автоматической упаковки/распаковки (boxing/unboxing) в olvm не предусмотрено (а значит, на значения value типа нельзя ссылаться через reference).

#### Система команд

   Система команд olvm делится на несколько классов

##### Команды управления выполнением

   В эту группу команд входят команды вызова функций, возврата из них, условного и безусловного перехода по адресу (относительно текущего) а так же взаимодействия с менеджером сопрограмм. Необходимо заметить, что менеджер сопрограмм не входит в состав виртуальной машины и предоставляется исполняемой программой.

   Большинство этих команд прикладному программисту непосредственно недоступны, только компилятору ol, в таком случае соответствующее им имя функции не приводится.

 * **20** APPLY (apply)
 * **24** RET
 * **50** RUN
 * **2** GOTO
 * **18** GOTO-CODE
 * **19** GOTO-PROC
 * **21** GOTO-CLOS
 * **27** SYS (sys)
 * **x0D** LDI, а так же ее варианты
   * **x4D** LDN
   * **x8D** LDT
   * **xCD** LDF
 * **1** REFI
 * **9** MOVE
 * **5** MOV2
 * **8** JEQ
 * **16** JP
 * **25** JF2 arity address, команда условного перехода, если арность вызова не соответствует заявленной

##### Команды, соответствующие примитивам языка

 * **60** (raw type list), конструктор "сырых" объектов в памяти, с его помощью можно, например, собрать свою функцию прямо из байткода. Например, саму же функцию raw можно собрать как `(define raw     (raw type-bytecode '(60 4 5 6  24 6)))`
 * **51** (cons a b)
 * **52** (car pair)
 * **53** (cdr pair)
 * **47** (ref obj n), возвращает n-й элемент obj, где obj должен быть reference типа. Для объектов, состоящих из последовательностей байт (таких, как string или byte-vector) возвращается именно байтовый элемент. Для остальных - обычный (например, для tuple).
 * **15** (type obj), возвращает тип объекта. Типов всего 64, вот неполный список:
   *  0, type-fix+ - value число (маленькое), позитивное
   * 32, type-fix- - value число (маленькое), негативное
   * 40, type-int+ - reference число (большое), позитивное
   * 41, type-int- - reference число (большое), негативное
   * 42, type-rational - рациональное число, представляет из себя нормализованную пару чисел числитель/знаменатель, к элементам числа можно обращаться через car/cdr
   * 43, type-complex - комплексное число, представляет из себя пару чисел абсцисса/ордината, к элементам числа также можно обращаться через car/cdr
   *  1, type-pair - пара, создаваемая с помощью cons
   *  2, type-tuple - кортеж
   *  3, type-string - строка
   *  4, type-symbol - символ (напоминаю, что символы в ol полноправные элементы языка)
   * 16, type-bytecode - байткод, то, что выполняет olvm
   * 17, type-proc
   * 18, type-clos
   * 31, type-thread-state
   * 15, type-vector-dispatch
   * 11, type-vector-leaf
   * 19, type-vector-raw
   * 14, type-rlist-node
   * 10, type-rlist-spine
   * 22, type-string-wide
   * 21, type-string-dispatch
   *  5, type-record (deprecated)
   * 24, type-ff
   * 25, type-ff-r
   * 26, type-ff-red
   * 27, type-ff-red-r
   *  8, type-ff-black-leaf
   * 20, type-eof (deprecated)
   * 13, type-const
   * 12, type-port
 * **36** (size obj), возвращает размер объекта
 * **22** (cast obj type), производит преобразование типа объекта. Используется в математической библиотеке для смены знака числа а также для задания значений портов stdin, stdout, stderr.
 * **45** (set obj n value), заменяет элемент obj в позиции n на value, в полном согласии с функциональной парадигмой программирования возвращает новый объект не изменяя старый
 * **10** (set! obj n value), мутатор (experimental support)
 * **11** (set-car! obj value), мутатор (experimental support). В качестве value поддерживаются только значения value-типов (type-fix+, type-fix-, type-const)
 * **12** (set-cdr! obj value), мутатор (experimental support). Аналогичен set-car!.
 * **54** (eq? a b), производит сравнение элементов a и b, если элементы value-типа, сравниваются их значения; если же reference, то адреса в памяти. За деталями обращаться в [R<sup>5</sup>RS](https://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r5rs-html/r5rs_8.html)
 * **44** (less? a b), производит сравнение элементов a и b, если элементы value-типа, сравниваются их значения; если же reference, то адреса в памяти. За деталями обращаться в [R<sup>5</sup>RS], возвращает true если объект a строго меньше объекта b

##### Математические команды
 * Основная часть команд описана в главе "[internals/numbers](?ru/internals/numbers)"
 * **33** (fxmax) - возвращает максимальное число value типа, название команды еще не стандартизировано
 * **34** (fxmbits) - возвращает количество бит в (fxmax) числе

##### Прочие
 * **61** (clock)
 * **63** (syscall n a b c), интерфейс с функциям операционной системы. В основном нумерация совпадает с таблицей системных вызовов linux 64-bit, вот список функций
   *  0, read
   *  1, write
   *  2, open
   *  3, close
   *  4, stat
   *  5, fstat
   * 16, ioctl (поддерживается только TIOCGETA команда, 19, для проверки терминал ли устройство ввода)
   * 41, socket (если включен дефайн HAS_SOCKETS)
   * 42, connect (если включен дефайн HAS_SOCKETS)
   * 48, shutdown (если включен дефайн HAS_SOCKETS)
   * 49, bind (если включен дефайн HAS_SOCKETS)
   * 50, listen (если включен дефайн HAS_SOCKETS)
   * 43, accept (если включен дефайн HAS_SOCKETS)
   * 23, select (если включен дефайн HAS_SOCKETS)
   * 51, getpeername (если включен дефайн HAS_SOCKETS)
   * 35, nanosleep
   * 59, execve
   * 60, exit
   * 63, uname
   * 78, getdents
   * 96, gettimeofday
   * 98, getrusage, (может отсутствовать в виртуальной машине, выключается в заголовочном файле olvm.h с помощью SYSCALL_GETRUSAGE, на данный момент отсутствует в сборке для Windows)
   * 99, sysinfo, (может отсутствовать в виртуальной машине, выключается в заголовочном файле olvm.h с помощью SYSCALL_SYSINFO, на данный момент отсутствует в сборке для Windows)
   * 157, prctl, (может отсутствовать в виртуальной машине, выключается в заголовочном файле olvm.h с помощью SYSCALL_PRCTL)
   * 62, kill
   * 201, time - в отличие от аналогичного системного вызова умеет не только возвращать время, но и форматировать его в нужный строковый формат
   * 174, dlopen
   * 176, dlclose
   * 177, dlsym
   * 178, dlerror
   * 1000, (undocumented) принудительно запустить сборку мусора
   * 1007, (undocumented) set memory limit
   * 1009, (undocumented) get memory limit
   * 1008, (undocumented) get machine word size
   * 1022, (undocumented) set ticker
   * 1014, (undocumented) set slice
   * 1016, (undocumented) getenv
   * 1017, (undocumented) system (deprecated)
   * 1117, (undocumented) get memory stats

 * **62** (vm:version), возвращает версию виртуальной машины в виде точечной пары ("OL" . "1.0")

##### Команды встроенной в язык хеш-таблицы

   В ol встроена поддержка быстрых однонаправленных хеш-таблиц, реализацию которых можно найти в библиотеке (owl ff). Эти таблицы представляют из себя красно-черное бинарное дерево, работа с которым построена в полном согласии с функциональной парадигмой программирования. Таким образом при добавлении в дерево новых элементов старое дерево не меняется. Однако не надо думать, что новая таблица является полным дублированием старой с соответствующими большими накладными расходами - это не так, дублируются только те элементы дерева, которые требуют перебалансировки и/или изменения. Желающие могут обратиться к [исходному коду](https://github.com/yuriy-chumak/ol/blob/master/owl/ff.scm).

 * **49** (ff:bind)
 * **43** (ff:red)
 * **42** (ff:black)
 * **46** (ff:toggle)
 * **41** (ff:red?)
 * **37** (ff:right?)

TBD.
---
layout: page
title:  "Общее преставление"
date: 2016-09-12 14:45:03 UTC
categories: ru
---

   Lisp, кто бы что не думал, не тарабарщина, Lisp - это божественный, безумно [древний](https://ru.wikipedia.org/wiki/IBM_704) язык! И невероятно простой. Научить лиспу можно даже дошкольника, лишь бы он умел читать и писать. Но вместе с этим из очень простых конструкций этого языка можно легко и быстро построить сложные, непостижимо умные программы.
   
   В этом разделе приводятся базовые сведения о минимально нужном наборе конструкций языка. С помощью этих знаний можно будет легко понимать приводимые примеры и перейти к более сложным вещам.
   
   В контексте изложения можно встретить разные наименования языка, в приложении к которому идет речь. Важно понимать различие:

  * Lisp, это базовый язык собственной персоной. Его общие концепции, философия и синтаксис. Присущи для всего семейства потомков (диалектов) языка.
  * Scheme, это один из самых распространенных диалектов языка (другим не менее распространенным является Common Lisp, а вообще - сотни их). Все, что помечено как Scheme - является специфическим именно для философии Scheme.
  * R<sup>5</sup>RS - один из упоминаемых стандартов Scheme (их несколько, R<sup>3</sup>RS, R<sup>4</sup>RS, ..., R<sup>7</sup>RS), на котором базируется базовая библиотека Ol. Этот стандарт расширяется набором SRFI.
  * И, собственно, сам Otus Lisp. Все помеченное этим именем, либо его часто используемым сокращением "Ol", специфично только и именно для описываемой реализации языка.
   
   Следует указать, что все помеченное как Lisp полностью включается в Scheme, а как Scheme в R<sup>5</sup>RS. Но не все из R<sup>5</sup>RS включается в Ol, так как Ol - чисто функциональный диалект, а R<sup>5</sup>RS и Scheme подразумевают также и императивные элементы поведения языка. Такие различия будут в обязательном порядке оговорены.
   
   Переходим к списку основных конструкций языка:
   
#### Комментарии

   Наименее существенная, но первая из конструкций языка - комментарий. Комментарии в лисп бывают однострочные и многострочные.
   
   Однострочные обозначаются точкой с запятой (;) и длятся до конца строки.
   
#### Списки

   Наиболее существенная, а так же важная для понимания философии языка, конструкция Lisp - списки. По большому счету, Lisp - это и есть списки, много списков, очень много списков списков.

   Списки являются самой необходимой конструкцией Lisp - даже его название расшифровывается как "обработчик списков" (LISt Processor). И сама программа, которую дают выполнить Lisp'у - тоже список.

   Конструируются списки с помощью круглых скобок - открывающей список левой скобки "(" и закрывающей список правой ")". А так как списков в программе много, то и скобок тоже много. Их количество у некоторых может вызывать даже некое возмущение, что давным-давно вылилось в старую добрую шутку об альтернативной расшифровке акромина Lisp как "Lots of Irritating Stupid Parentheses" (много раздражающих глупых скобок). Но к скобкам очень быстро привыкается, они легко занимают свое место в голове и при правильном форматировании исходного текста программы не только не мешают, но существенно облегчают чтение программы. Что, впрочем, относится к любому языку программирования.
   
   Между скобками размещаются элементы списка, разделенные пробельными сомволами (как минимум - одним, как максимум - на ваше усмотрение), слева направо. Никаких ограничений на типы элементов не накладывается - это могут быть числа, строки, другие списки. Вкладывая списки в списки, мы формируем целое дерево элементов (если нарисовать списки соответственно уровню их вложенности и местом, где они должны были быть размещены - получится этакое стилизованное дерево). Это дерево в Lisp называется AST (АСД) - Abstract Syntax Tree (абстрактное синтаксическое дерево).

   Если список отдать на интерпретацию Lisp'у, он будет его понимать строго опеределенным образом - первый элемент списка Lisp всегда будет считать операцией - командой, которую надо выполнить над оставшейся частью списка. Эта логика будет применена Lisp'ом к каждому элементу, если он в свою очередь является тоже списком; и так далее рекурсивно (разбор понятия *рекурсии* тоже оставим надлежащему времени и месту), пока не останется необработанных списков. Этот процесс и называется процессом *вычисления* Lisp-программы (в терминах Lisp - EVAL).
   
   Вот несколько примеров списков, которые можно сразу опробовать *вычислить* в терминале:

<pre><code id="list1" data-language="scheme">(* 1 2 3 4 5 6 7 8 9)</code><button class="doit" onclick="doit(list1.textContent)">отправить в терминал</button></pre>

<pre><code id="list2" data-language="scheme">(print "Hello John!")</code><button class="doit" onclick="doit(list2.textContent)">отправить в терминал</button></pre>

<pre><code id="list3" data-language="scheme">(print "Ну или привет, если так понятнее.")</code><button class="doit" onclick="doit(list3.textContent)">отправить в терминал</button></pre>

<pre><code id="list4" data-language="scheme">(print "2+2 = " (+ 2 2))</code><button class="doit" onclick="doit(list4.textContent)">отправить в терминал</button></pre>

   Существует довольно небольшой список (да, снова список, и это не каламбур) базовых команд, и довольно большой список построенных из них команд посложнее, которые собраны в стандарты (для Scheme - это, например, [R<sup>5</sup>RS](http://www.schemers.org/Documents/Standards/R5RS/) Scheme, есть и другие; Otus Lisp реализует большую часть этого стандарта и может выполнять многие программы написанные для других диалектов Lisp, следующих указанному стандарту). Стандарт будет рассмотрен в соответствующем месте, сейчас же стоит упомянуть, что **print** выводит элементы списка на стандартное устройство вывода (например, в консоль), **car** возвращает первый элемент списка, **cdr** возвращает оставшуюся без первого элемента часть списка, а **\*** - умножает элементы списка между собой.
   
   Странность названий car и cdr сложилась [исторически](https://en.wikipedia.org/wiki/CAR_and_CDR), их надо просто запомнить.

   Что еще можно делать со списками мы рассмотрим позже.

#### Кортежи
   
   Otus Lisp поддерживает специализированную форму списка заранее заданной длины - кортеж. В отличие от обычных списков некоторые операции с кортежами существенно быстрее. Например, время доступа к любому элементу кортежа одинаково, в то время как у списка доступ к первому элементу самый быстрый, а к последнему самый медленный. Также, есть несколько специальных конструкций языка, ведущих к более интуитивно понятному написанию программ - речь идет о конструкции tuple-case. 
   
   Более детально о кортежах будет рассказано в специальном отведенном для кортежей разделе.

#### Числа
   
   Следующей базовой вещью в Lisp являются числа. Числа подразделяются на несколько классов:

  1. Класс integer чисел - это целые (Z) числа, их размер ограничен только размером оперативной памяти компьютера. В отличие от большинства языков программирования, они могут легко превышать размер регистра процессора, на котором выполняется программа.
     <pre><code id="Z1" data-language="scheme">123456789876543212345678987654321</code><button class="doit" onclick="doit(Z1.textContent)">отправить в терминал</button></pre>
     <pre><code id="Z2" data-language="scheme">(* 12345678987654321 98765432123456789)</code><button class="doit" onclick="doit(Z2.textContent)">отправить в терминал</button></pre>
      
  2. Класс rational чисел - это рациональные (Q) числа, которые представлены в виде дроби. В числителе дробь всегда содержит целое число, в знаменателе - натуральное (целое, большее нуля). Дробь рационального числа всегда является несократимой - если попытаться ввести сократимую дробь, то интерпретатор Lisp автоматически ее сократит; если возможно, то даже до целого числа. В Ol числитель можно извлечь с помощью конструкции car, знаменатель - cdr.
     <pre><code id="Q1" data-language="scheme">(print "todo: добавить пример")</code><button class="doit" onclick="doit(Q1.textContent)">отправить в терминал</button></pre>
      
  3. Класс complex чисел - это комплексные (C) числа, которые представлены в виде A+Bi, где A и B - целые или натуральные числа, i - мнимая единица. Пробелы между частями комплексного числа не допускаются, иначе они будут проинтерпретированы как самостоятельные, раздельные элементы списка. В Ol действительную часть числа можно извлечь с помощью конструкции car, мнимую - cdr. В свою очередь, если это натуральные числа, к ним можно снова применить car и cdr.
     <pre><code id="C1" data-language="scheme">(* 0+3i 3-2i)  ; ==> 6+9i</code><button class="doit" onclick="doit(C1.textContent)">отправить в терминал</button></pre>

  4. Иррациональные числа (I) в Ol не поддерживаются. Но работу с ними можно организовать с помощью механизма расширений, о котором разговор будет в соответствующем разделе.

   Для работы с числами предназначена математическая библиотека (owl math).

   Более детально о внутреннем представлении чисел в Ol можно почитать в разделе о [внутреннем устройстве](?ru/internals/numbers) виртуальной машины Ol.


#### Строки

   Наряду с числами Lisp умеет оперирировать непосредственным текстом - строками. Строки в Ol заключаются в кавычки (") и полностью поддерживают юникод.
   
   Для работы со строками используется набор специализированных функций, таких как string-length, string-eq?, string-append, substring и другие. Необходимость этих функций обусловлена тем, что с целью обеспечения быстрой и эффективной работы внутреннее представление строк является достаточно сложным (например, в Ol при добавлении к очень длинной строке короткой, длинная не будет дублироваться, теряя ресурсы на эту операцию). 

   TBD.

#### Символы
   
   TBD.

#### Порты

   TBD.

#### Специальные формы

   Специальными формами в Lisp называются такие конструкции языка, которые не могут быть выражены способами самого языка. Например, квотирующая форма quote.

   В качестве базовых синтаксических конструкций Otus Lisp поддерживает минимально нужный набор специальных форм. Те из них, которые совпадают со специальными формами Lisp имеют соответствующее общее название. Те же, которые являются специфическими для Otus Lisp, имеют префикс 'ol:'. Вот список этих форм.
   
  * quote - квотирующая форма для символа, препятствует его интерпретации. Для упрощения ввода и чтения программы часто заменяется символом одинарной кавычки ('). Таким образом 'me является эквивалентом (quote me).
  * lambda - объявление лямбда-функции, имеет несколько возможных вариантов объявления:
    * (lambda () <body>) - лямбда без аргументов
    * (lambda (a) <body>) - лямбда с одним аргументом
    * (lambda (a b) <body>) - лямбда с двумя аргументами
    * (lambda (a b <c d ...> <body>) - лямбда с тремя, четырьмя и т.д. аргументами)
    * (lambda args <body>) - лямбда с любым количеством аргументов, аргументы помещаются в args списком.
    * (lambda (a . x) <body>) - лямбда с одним и более аргументами, первый аргумент помещается в a, все остальные списком в x. 
    * (lambda (a b . x) <body>) - лямбда с двумя и более аргументами, первый аргумент помещается в a, второй в b, все остальные списком в x.
    * (lambda (a b <c d ...> . x) <body>) - лямбда с тремя, четырьмя и т.д. и более аргументами, первый аргумент помещается в a,     второй в b, третий в c, и т.д., все остальные списком в x.
  * values - возвращает несколько значений одновременно
    * (let* ((a b c (values 1 2 3))) (print c b a)) => 321
  * receive - передает несколько значений одновременно (созданных через values) в соответствующую лямбду, количество значений должно совпасть с количеством аргументов лямбды
    * (receive (values 1 2 3) (lambda (a b c) (print c b a))) => 321
    
   Специфические для Otus Lisp специальные формы:
  * ol:set - связывание символа в текущем окружении со значением, прототип формы define
    * (ol:set x 12) - связывает символ x со значением 12, (print x) => 12
  * ol:let - связывает список переменных со списком значений на время выполнения тела формы
    * (ol:let (a b c) (1 2 3) (print c b a)) => 321
  * ol:ifc - "IF with Condition" - оператор ветвления, имеет пять аргументов (<тип> <параметр-1> <параметр-2> <если-истина> <если-ложь>)
    * (let ((a 3) (b 4)) (ol:ifc 0 a b (print "a и b равны") (print "a и b НЕ равны")))
  * ol:ifa - "IF with Arity" - оператор ветвления, имеет два аргумента, выполняет первый, если совпадает арность, иначе выполняет второй
    
   С помощью формы ol:ifa эффективно реализуется, например, форма case-lambda из srfi-16.
   
   На первый взгляд, формы receive и ol:let взаимозаменяемы, однако это не так. Форма ol:let сначала размещает переменные в окружении, потом вычисляет значения и уже после этого связывает переменные со значениями. Что позволяет объявлять взаиморекурсивные конструкции. Форма receive наоборот, сначала вычисляет значения и уже потом с помощью обявления лямбды размещает переменные в окружении и связывает их со значениями.
   
   TBD.
   
#### Функции

   TBD. (а также внешние функции, результат (dload))

#### Макросы

   TBD.

   Some works more.

#### Словари (ассоциативные массивы)

   Otus Lisp поддерживает словари - специализированный тип даных с довольно быстрыми операциями вставки значения и поиска по ключу. В качестве ключа могут быть использованы атомарные числа и символы.
   
   TBD.



---
layout: page
title:  "Общее преставление"
date: 2016-06-01 14:07:03 UTC
categories: ru
---

   Lisp, кто бы что не думал, не тарабарщина, Lisp - это божественный, безумно древний язык! И невероятно простой. Научить лиспу можно даже дошкольника, лишь бы он умел читать и писать. Но вместе с этим из очень простых конструкций этого языка можно легко и быстро построить сложные, непостижимо умные программы.
   
   В этом разделе будут приведены базовые сведения о минимально нужном наборе конструкция языка. С помощью этих знаний можно будет легко понимать приводимые примеры и перейти к более сложным вещам.
   
   В контексте изложения будут встречаться разные наименования языка, в приложении к которому идет речь. Важно понимать различие:

   * Lisp, это язык собственной персоной. Его базовые концепции, философия и синтаксис. Это самые общие для всего семейства потомков базового языка.
   * Scheme, это один из самых распространенных диалектов языка (другим является Common Lisp, а вообще - сотни их). Все, что помечено как Scheme - является специфическим именно для философии Scheme.
   * R<sup>5</sup>RS - один из стандартов Scheme (их несколько, R<sup>3</sup>RS, R<sup>4</sup>RS, R<sup>7</sup>RS), на котором базируется базовая библиотека Ol. Этот стандарт расширен набором SRFI.
   * И, собственно, сам Ol - Otus Lisp. Все помеченное этим именем специфично только и именно для описываемой реализации языка.
   
   Следует указать, что все помеченное Lisp полностью включается в Scheme, а Scheme в R<sup>5</sup>RS. Но не весь R<sup>5</sup>RS включается в Ol, так как Ol - чисто функциональный диалект, а R<sup>5</sup>RS и Scheme подразумевают и императивное поведение языка. Такие различия будут в обязательном порядке оговорены.
   
   Переходим к списку основных конструкций языка:

#### Списки

   Главное в Lisp - это списки, много списков, очень много списков списков.

   Списки являются самой базовой конструкцией Lisp - его название не просто так расшифровывается как "обработчик списков" (LISt Processor). Все, с чем работает Lisp, является списками. И сама программа, которую дают выполнить Lisp'у - тоже список.

   Конструируются списки с помощью круглых скобок - открывающей список скобки "(" и закрывающей его ")". А так как списков в программе много, то и скобок тоже много. Их количество у некоторых может вызывать даже некоторое возмущение, которые выражается в старом добром прочтении акронима Lisp как "Lots of Irritating, Stupid Parentheses" (много раздражающих, глупых скобок). Но к скобкам быстро привыкается, они легко занимают свое место и при правильном форматировании исходного текста программы нисколько не мешают. Что, впрочем, относится к любому языку программирования.
   
   Между скобками размещаются элементы списка, разделенные пробелами, слева направо. Никаких ограничений на элементы не накладывается, это могут быть числа, строки, другие списки. Вкладывая списки в списки, мы формируем целое дерево элементов (если расположить списки соответственно уровню их вложенности и местом, где они должны были быть размещены). Это дерево в Lisp называется AST (АСД) - Abstract Syntax Tree (абстрактное синтаксическое дерево).

   Вот несколько примеров списков

<pre><code id="list1" data-language="scheme">(* 1 2 3 4 5 6 7 8 9)</code><button class="doit" onclick="doit(list1.textContent)">отправить в терминал</button></pre>

<pre><code id="list2" data-language="scheme">(print "Hello, John!")</code><button class="doit" onclick="doit(list2.textContent)">отправить в терминал</button></pre>

<pre><code id="list3" data-language="scheme">(print "Ну или привет, если так понятнее.")</code><button class="doit" onclick="doit(list3.textContent)">отправить в терминал</button></pre>

<pre><code id="list4" data-language="scheme">(print "2+2 = " (+ 2 2))</code><button class="doit" onclick="doit(list4.textContent)">отправить в терминал</button></pre>

   Если список отдать на интерпретацию Lisp'у, он будет его понимать строго опеределенным образом - первый элемент списка Lisp будет считать операцией - командой, которую надо выполнить над оставшейся частью списка. Эта логика будет применена Lisp'ом к каждому элементу, если он в свою очередь является тоже списком; и так далее рекурсивно (разбор понятия <i>рекурсии</i> тоже оставим надлежащему времени и месту), пока не останется необработанных списков. Этот процесс и называется процессом интерпретации Lisp-программы (в терминах Lisp - EVAL).
   
   Существует довольно небольшой список (да, снова список, и это не игра слов) базовых команд, и довольно большой список построенных из них команд посложнее, которые собраны в стандарты (для Scheme - это, например, [R<sup>5</sup>RS](http://www.schemers.org/Documents/Standards/R5RS/){:target="_blank"} Scheme, есть и другие; Ol реализует большую часть этого стандарта и может выполнять многие программы написанные для других диалектов Lisp следующих указанному стандарту). Сейчас стоит упомянуть, что **print** выводит элементы списка на стандартное устройство вывода (в консоль), **car** возвращает первый элемент списка, **cdr** возвращает оставшуюся часть списка (без первого элемента), а **\*** - умножает оставшиеся элементы списка.

   Что еще можно делать со списками мы рассмотрим позже.

#### Числа

   В Lisp числа подразделяются на несколько классов:

1. Класс integer чисел - это целые (Z) числа, их размер ограничен только размером оперативной памяти компьютера. В отличие от большинства языков программирования, они могут легко превышать размер регистра процессора, на котором выполняется программа.

   <pre><code id="Z1" data-language="scheme">123456789876543212345678987654321</code><button class="doit" onclick="doit(Z1.textContent)">отправить в терминал</button></pre>

   <pre><code id="Z2" data-language="scheme">(* 12345678987654321 98765432123456789)</code><button class="doit" onclick="doit(Z2.textContent)">отправить в терминал</button></pre>
      
2. Класс rational чисел - это рациональные (Q) числа, которые представлены в виде дроби. В числителе дробь всегда содержит целое число, в знаменателе - натуральное (целое, большее нуля). Дробь рационального числа всегда является несократимой - если попытаться ввести сократимую дробь, то интерпретатор Lisp автоматически ее сократит; если возможно, то даже до целого числа. В Ol числитель можно извлечь с помощью конструкции car, знаменатель - cdr.

   <pre><code id="Q1" data-language="scheme">(print "todo: добавить пример")</code><button class="doit" onclick="doit(Q1.textContent)">отправить в терминал</button></pre>
      
3. Класс complex чисел - это комплексные (C) числа, которые представлены в виде A+Bi, где A и B - целые или натуральные числа, i - мнимая единица. Пробелы между частями комплексного числа не допускаются, иначе они будут проинтерпретированы как самостоятельные, раздельные элементы списка. В Ol действительную часть числа можно извлечь с помощью конструкции car, мнимую - cdr. В свою очередь, если это натуральные числа, к ним можно снова применить car и cdr.

   <pre><code id="C1" data-language="scheme">(* 0+3i 3-2i)
; ==> 6+9i
</code><button class="doit" onclick="doit(C1.textContent)">отправить в терминал</button></pre>

4. Иррациональные числа в Ol не поддерживаются. Но работу с ними можно организовать с помощью механизма расширений, о котором разговор будет в соответствующем разделе.

Более детально о внутреннем представлении чисел в Ol можно почитать в разделе о [внутреннем устройстве](?ru/internals/numbers) виртуальной машины Ol.
   
#### Строки

   TBD.

#### Символы

   TBD.

#### Порты

   TBD.

#### Специальные формы

   В качестве базовых синтаксических конструкций Otus Lisp поддерживает несколько специальных форм. Те из них, которые совпадают со специальными формами Lisp имеют соответствующее общее название. Те же, которые являются специфическими для Otus Lisp, имеют префикс 'ol:'. Вот список этих форм.
   
  * quote - квотирующая форма для символа, препятствует его интерпретации. Для упрощения ввода и чтения программы часто заменяется символом одинарной кавычки. Таким образом 'me является эквивалентов (quote me).
  * lambda - объявление лямбда-функции, имеет несколько возможных вариантов задания:
    * (lambda () <body>) - лямбда без аргументов
    * (lambda (a) <body>) - лямбда с одним аргументом
    * (lambda (a b) <body>) - лямбда с двумя аргументами
    * (lambda (a b <c d ...> <body>) - лямбда с тремя, четырьмя и т.д. аргументами)
    * (lambda args <body>) - лямбда с любым количеством аргументов, аргументы помещаются в args списком.
    * (lambda (a . x) <body>) - лямбда с одним и более аргументами, первый аргумент помещается в a, все остальные списком в x. 
    * (lambda (a b . x) <body>) - лямбда с двумя и более аргументами, первый аргумент помещается в a, второй в b, все остальные списком в x.
    * (lambda (a b <c d ...> . x) <body>) - лямбда с тремя, четырьмя и т.д. и более аргументами, первый аргумент помещается в a,     второй в b, третий в c, и т.д., все остальные списком в x.
  * values - возвращает несколько значений одновременно
    * (let* ((a b c (values 1 2 3))) (print c b a)) => 321
  * receive - передает несколько значений одновременно (созданных через values) в лямбду
    * (receive (values 1 2 3) (lambda (a b c) (print c b a))) => 321
    
   Специфические для Otus Lisp специальные формы:
  * ol:set - связывание символа в текущем окружении со значением, прототип формы define
    * (ol:set x 12) - связывает символ x со значением 12, (print x) => 12
  * ol:let - связывает список переменных со списком значений на время выполнения тела формы
    * (ol:let (a b c) (1 2 3) (print c b a)) => 321
  * ol:if - оператор ветвления, имеет пять аргументов (<тип> <параметр-1> <параметр-2> <если-истина> <если-ложь>) 
    * (let ((a 3) (b 4)) (ol:if 0 a b (print "a и b равны") (print "a и b НЕ равны")))
  * _case-lambda - эта специальная форма еще не имеет установившегося названия и является оптимизацией для case-lambda из srfi-16.
    * TBD.
    
   На первый взгляд, формы receive и ol:let взаимозаменяемы, однако это не так. Форма ol:let сначала размещает переменные в окружении, потом вычисляет значения и уже после этого связывает переменные со значениями. Что позволяет объявлять взаиморекурсивные конструкции. Форма receive наоборот, сначала вычисляет значения и уже потом с помощью обявления лямбды размещает переменные в окружении и связывает их со значениями.
   
   TBD.
   
#### Функции

   TBD. (а также внешние функции, результат (dload))

#### Макросы

   TBD.

   Some works more.

